#!/usr/bin/env -S poetry run python
import hashlib
import io
import operator
import os
import subprocess
from typing import Optional, Dict

import defopt
import mlflow
from mlflow.tracking import MlflowClient


class KeywordArguments(dict, Dict[str, str]):
    @classmethod
    def from_string(cls, string: str) -> 'KeywordArguments':
        return KeywordArguments({
            key.strip(): value
            for key, value
            in (kwarg.split('=') for kwarg in string.split(','))
        })


def run_command(*args: str, stdin: Optional[str] = None) -> str:
    process = subprocess.Popen(
        args,
        stdin=subprocess.PIPE,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        close_fds=True,
        universal_newlines=True,
    )

    stdout, stderr = process.communicate(input=stdin)

    if process.returncode != 0:
        raise OSError(stderr)

    response = stdout.strip()

    return response


def create_run_id(
        experiment_name: str,
        user: str,
        entry_point: str,
        repository_url: str,
        version: str,
        branch: str,
        path: str,
        image: str,
) -> str:

    client = MlflowClient()

    experiment = client.get_experiment_by_name(experiment_name)

    experiment_id = experiment.experiment_id if experiment else client.create_experiment(experiment_name)

    run = client.create_run(experiment_id, tags={
        'mlflow.user': user,
        'mlflow.project.env': 'docker',
        'mlflow.project.entryPoint': entry_point,
        'mlflow.source.type': 'PROJECT',
        'mlflow.source.name': f'https://{repository_url.removesuffix(".git")}#{path}',
        'mlflow.source.git.commit': version,
        'mlflow.source.git.branch': branch,
        'mlflow.source.git.repoURL': repository_url,
        'mlflow.docker.image.name': image,
    })

    run_id = run.info.run_id

    return run_id


def get_arguments(run_id: str) -> KeywordArguments:
    return KeywordArguments({
        key: str(value)
        for key, value
        in mlflow.get_run(run_id).data.params.items()
        if value != 'None'
    })


def get_experiment_name(run_id: str) -> str:
    return mlflow.get_experiment(mlflow.get_run(run_id).info.experiment_id).name


def get_entry_point(run_id: str) -> str:
    return mlflow.get_run(run_id).data.tags['mlflow.project.entryPoint']


def get_version(run_id: str) -> str:
    return mlflow.get_run(run_id).data.tags['mlflow.source.git.commit']


def get_repository_url() -> str:
    repository_url = run_command('git', 'config', '--get', 'remote.origin.url')

    if repository_url.startswith('https://'):
        repository_url = repository_url.removeprefix('https://')
    else:
        repository_url = repository_url.removeprefix('git@').replace(':', '/')

    return repository_url


def main(
        *,
        experiment_name: Optional[str] = None,
        entry_point: Optional[str] = None,
        version: Optional[str] = None,
        run_id: Optional[str] = None,
        arguments: Optional[KeywordArguments] = None,
        job_template_path: str = 'bin/templates/k8s.yaml',
) -> None:
    """
    Launches a Kubernetes Job that runs an MLFlow entry point

    :param experiment_name: The MLFlow experiment name
    :param entry_point: The name of the MLFlow entry point
    :param version: A commit hash, branch name or tag name, specifying the version of the code to run
    :param run_id: MLFlow run ID to continue
    :param arguments: Comma-separated list of key=value arguments for the entry point
    :param job_template_path: Job template path
    """
    assert experiment_name or run_id
    assert entry_point or run_id
    assert arguments is None or 'run-id' not in arguments

    arguments = arguments if arguments else get_arguments(run_id) if run_id else KeywordArguments()

    experiment_name = experiment_name if experiment_name else get_experiment_name(run_id)
    entry_point = entry_point if entry_point else get_entry_point(run_id)
    version = run_command('git', 'rev-parse', version if version else get_version(run_id) if run_id else 'HEAD')

    repository_url = get_repository_url()
    path = run_command('git', 'rev-parse', '--show-prefix').strip('/')
    branch = run_command('git', 'branch', '--show-current')

    with io.open(os.path.join(os.getcwd(), job_template_path), mode='r') as job_file:
        job_template = job_file.read()

    identifier = version + ''.join(
        f'{key}{value}'
        for key, value
        in sorted(arguments.items(), key=operator.itemgetter(0))
    )
    identifier = hashlib.md5(bytes(identifier, 'utf-8')).hexdigest()

    job_name = f'{entry_point}-{identifier[:10]}'

    if not run_id:
        run_id = create_run_id(
            experiment_name=experiment_name,
            user=os.environ['USER'],
            entry_point=entry_point,
            repository_url=repository_url,
            version=version,
            branch=branch,
            path=path,
            image=os.environ['TRAINING_IMAGE'],
        )

    arguments['run-id'] = run_id

    job_arguments = [
        f'"{argument}"' for argument in [
            f'https://{os.environ["GITHUB_TOKEN"]}@{repository_url}#{path}',
            '--experiment-name', experiment_name,
            '--entry-point', entry_point,
            '--version', version,
            '--run-id', run_id,
        ] + [
            argument
            for key, value in arguments.items()
            for argument in ('-P', f'{key}={value}')
        ]
    ]

    job_definition = job_template.format(
        name=job_name,
        image=os.environ['TRAINING_IMAGE'],
        args=f'[{", ".join(job_arguments)}]',
        slack_url=os.environ['SLACK_URL'],
        slack_user=os.getenv('SLACK_USER', ''),
    )

    run_command('kubectl', 'delete', 'job', '--ignore-not-found', job_name)
    print(run_command('kubectl', 'apply', '-f', '-', stdin=job_definition))


if __name__ == '__main__':
    defopt.run(
        funcs=main,
        parsers={
            KeywordArguments: KeywordArguments.from_string,
        },
    )
